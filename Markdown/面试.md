## 项目
+ 项目名称是教学小栈，是一个基于Vue开发的前端学生信息管理系统，我在项目中负责教师登录、学生信息及成绩登记模块的开发，项目中使用的技术栈有vue-router、vuex、elementui、axios等。
+ 项目的难点有：
    + 组件间的通信
        1. 父子间的通信：
            + 使用了`props + $emit`：使用props实现父组件向子组件传值，在父组件中定义一个函数，然后通过v-on进行监听，在子组件中使用$emit进行触发，父组件中定义的函数中参数就可以获得子组件传递的数据。
        2. 兄弟组件之间的通信：
            + 增加一个父组件，通过该父组件实现通信
        3. 隔代组件之间的通信：
            + `$attrs + $listeners`：父组件向中间组件传参，在中间组件中使用v-bind="$attrs"进行接收，而$attrs会向子组件继续传递，在子组件汇总通过this.$attrs就可以获得。（$attrs可以获取父组件中的非props属性）。$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件。
        4. 全局事件总线
           + 先通过new一个空的vue实例，抛出该实例。再在想进行通讯的组件中引入那个空vue实例，并且使用vue实例名.$emit(‘自定义属性名’,要传递的数据) 向目标组件发送数据。最后在目标组件中通过vue实例名.$on(‘传递过来的属性名’,将数据赋值给当前data中的属性)进行监听。
        5. vuex



## 语义化标签：
1. 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
2. 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
3. 方便其他设备解析，如盲人阅读器根据语义渲染网页。
4. 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。

## 垂直水平居中
1. absolute定位，margin-left和top各50%，然后transform-50%；
2. absolute定位，margin: auto;
2. flex布局，使用justify-content:center;和align-items:center;

## cookie、localStorage、sessionStorage
### Cookie是服务器端发给客户端的文本文件,但只能储存4kb的数据;目的是用于辨别用户身份，记录跟踪购物车的商品信息（如数量）、记录用户访问次数等。
+ cookie的内容主要包括：名字name，值value，过期时间expires，路径path和域domain。路径和域一起构成cookie的作用范围。
+ 一般cookie储存在内存里，若设置了过期时间则储存在硬盘里，浏览器页面关闭也不会失效，直到设置的过期时间后才失效。若不设置cookie的过期时间，则有效期为浏览器窗口的会话期间，关闭浏览器窗口就失效。
### WebStorage——字符串的格式储存的（setItem、getItem、removeItem、clear）
+ localStorage的生命周期是永久，除非手动去清除，否则永远都存在，他的储存大小是5MB，仅在客户端浏览器上储存，不参与服务器的通信。
+ sessionStorage是在同源的同窗口中，始终存在的数据，只要浏览器不关闭，即使是刷新或者进入同源的另一个页面，数据仍在。同时打开“独立”的窗口，即使是同一个页面，sessionStorage的对象也是不同的。关闭窗口后sessionStorage就会被销毁。
+ 好处：
    1. 减少网络流量
    2. 快速显示数据
    3. 临时存储
### 异同：
+ 同：都保存在浏览器端，且都是同源的
+ 异：
    1. cookie始终在同源的http请求中携带，而webstorage仅在本地保存不会发送给浏览器。
    2. 存储大小不同。
    3. 数据有效期不同。
    4. 作用域不同。sessionStorage不共享，即使是同一页面；localStorage和cookie在同源窗口中都是共享的。
    5. webStorage支持事件通知机制，可以将数据更新通知给监听者。
    6. webStorage的api接口使用更方便。

## 缓存策略——强缓存和协商缓存
### 强缓存-本地缓存：当浏览器请求资源的时候，如果请求的资源在本地的缓存资源，那么浏览器就不会发送真正的请求给服务器。（响应头中的Cache-Control记录资源在客户端缓存的最大有效期，通过对比上一次返回的响应头中该属性的值来确定是否存在于本地）
### 协商缓存：使用服务器和浏览器之间的协商来确定是否使用缓存。
+ 当浏览器请求一个页面时，它会在请求中附加 “If-Modified-Since” 和 “If-None-Match” 头。这些头中包含了浏览器上一次请求的时间和资源的 ETag 值。服务器收到请求后，会检查资源是否发生了变化。如果没有变化，则返回 304 状态码，表示资源未变化，并在响应头中设置 “Last-Modified” 和 “ETag”。浏览器收到响应后，会使用本地缓存。如果服务器资源发生了变化，则会返回 200 状态码和最新的资源，并在响应头中设置 “Last-Modified” 和 “ETag”。浏览器收到响应后，会更新本地缓存。

## 浏览器状态码
### 1xx：信息，表示临时响应并需要请求者继续执行操作
### 2xx：成功
### 3xx：重定向
+ 301：页面永久转移，自动将请求者转移到新位置
+ 302：页面临时转移，请求者应继续使用原有位置进行以后的请求
+ 304：未修改，使用本地缓存
### 4xx：客户端错误，请求包含语法错误或无法完成请求
### 5xx：服务器处理请求时发生错误

# CSS布局的三种机制
## 普通流（标准流）
### 块级元素独占一行，从上向下顺序排列。
### 行级元素从左到右顺序排列，碰到父元素边缘则自动换行。
## 浮动float——脱离文档流（不对其他盒子布局产生影响），但不脱离文本流（会影响其他盒子中文字的排列）
+ 为了使多个块级盒子水平排列成一行；实现盒子的左右对齐；控制图片，实现文字环绕图片的效果。
+ 添加float属性的元素会漂浮在普通流的上面
### 
## 定位position

## flex布局
### 父容器的属性
+ flex-direction
+ flex-wrap
+ flex-flow
+ justify-content
+ align-items
+ align-content
### 子容器的属性
+ order
+ align-self
+ flex
+ flex-grow
+ flex-shrink
+ flex-basis
### flex布局会导致子元素的float、clear和vertical-align属性失效，可能导致width和height属性失效

# 长宽
## 文字相关
![文字相关](./img/%E6%96%87%E5%AD%97%E7%9B%B8%E5%85%B3%E5%AE%BD%E9%AB%98.png)